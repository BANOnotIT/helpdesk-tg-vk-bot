В этом файле собран код настройки подключения к базе данных,
описания моделей и создания соответствующих таблиц в базе при подключении

```python
from enum import Enum, unique
from peewee import Model, IntegerField, PostgresqlDatabase, TextField, CompositeKey
from urllib3.util import parse_url
from config import * 
```

В начале файла перечислен список модулей, которые мы будем использовать для написания работы с базой.
Модулем в Python называется любой файл с программой
Каждая программа может импортировать модуль и получить доступ к его классам, функциям, объектам и переменным

Подключать модули можно с помощью инструкции import - так в наш файл будет импортирован определенный модуль
и мы сможем обращаться к его объектам через точку, например
```python
import math
math.ceil(5.6) # округление числа до ближайшего большего целого

# так же можно задавать алиасы (короткие имена) импортированным модулям, это обычно используется для упрощения записи
import some_module_with_very_long_name as short_name
short_name.doWork()
```

Еще можно импортировать модули через инструкцию from - именно её мы используем в нашем файле
Синтаксис: 
from *название модуля* import *перечисление имен атрибутов, которые вы хотите подключить в ваш файл, либо "*" чтобы подключить все*

enum - встроенный в python модуль
peewee - модуль, написанный кем-то, который мы установили с помощью pip
urllib3.util - встроенный в python модуль
config - модуль, с различными параметрами, который мы сами написали ранее


```python
def get_database():
    parsed_url = parse_url(db_url) # db_url из config

    # Берём из auth имя пользователя и пароль от БД
    username, password = parsed_url.auth.split(':')

    return PostgresqlDatabase(
        parsed_url.path[1:],  # Пропускаем первый "/", так как он не является названием БД
        host=parsed_url.host,
        user=username,
        password=password
    )
```

Здесь мы видим объявление функции get_database
Функция, это кусок связанного по смыслу (выполняющего одну задачу) кода, сохраненный с определенным именем, чтобы переиспользовать в дальнейшем
В питоне функции объявляются с помощью инструкции def, после которой через пробел следует название функции,
затем круглые скобки, внутри которых перечисляется список параметров,которые могут быть переданы в функцию, а затем двоеточие.
Внутри блока функции код пишется с отступом в 4 пробела вправо от уровня первого символа названия
В конце функция возвращает некоторое значение или объект с помощью return


Первое, что мы видим в нашей функции, это сохранение в переменную parsed_url результата вызова функции parse_url из модуля urllib3.util,
с передачей ей в качестве параметра db_url из модуля config

Пример вызова parse_url
```python
>>> parse_url('http://google.com/mail/')
Url(scheme='http', host='google.com', port=None, path='/mail/', ...) # (объект, возвращенный parsed_url)
```

Функция возвращает экземпляр класса PostgresqlDatabase, который был создан с передачей ему необходимых параметров
Что же это значит?
Когда-то давно программисты, чтобы не писать один и тот же код много раз, сначала придумали объединять его в структуры
(они могли хранить лишь набор полей с указанием типа данных для каждого поля).
Так можно было описать структуру Человека и указать в ней, что каждый человек должен иметь поля рост, вес, возраст и страна рождения.
А затем просто для каждого пользователя создавать копию этой структуры, указывая рост, вес, возраст и страну рождения данного конкретного человека.

Затем придумали помещать в структуры еще и функции - так появились классы, своеобразные чертежи предметов,
где написано какие поля обязательно должен иметь каждый предмет, а так же какие действия он может совершать.
Некоторые классы требуют, что при создании очередного экземпляра (предмета, созданного по чертежу в виде класса) их типа им были переданы некоторые начальные параметры.

Также появилось наследование - можно сказать, что у класса A, есть предок - класс B
и все свойства и функции класса B будут доступны в классе А, где их можно изменить (переопределить)

В конце функции get_database мы видим, как создается экземпляр класса PostgresqlDatabase,
которому мы передаем название нашей базы данных, её хост, имя пользователя для подключения и пароль.

Затем новосозданный экземпляр возвращается наружу (туда, откуда эта функция была вызвана)

```python
database = get_database() # сохраняем экземпляр класса PostgresqlDatabase в переменную, внутри него, при создании экземпляра, настроилось сетевое подключение к базе
```

```python
@unique
class EUserState(Enum):
    initial = 0
    authorizing = 1
    base = 2
    integrating_tg = 3
    integrating_vk = 4
    trading = 5

    @classmethod
    def as_choices(cls):
        return [(item[1].value, item[0]) for item in cls.__members__.items()]
```

Здесь мы видим объявление класса EUserState, который наследуется от класса Enum из модуля enum.
У клиента чат-бота есть небольшой набор состояний, в котором может находиться его диалог с ботом.
У нас это:
initial (начальное состояние, куда попадают пользователи, только начавшие диалог), 
authorizing (пользователь начал авторизовываться),
base (обычное состояние пользователя),
integrating_tg (пользователь пытается привязать аккаунт в telegram),
integrating_vk (пользователь пытается привязать аккаунт в vk),
trading (пользовтель в процессе торговли).
В программировании для хранения таких ограниченных вещей используются
"типы данных с ограниченным списком значений", по-другому: enumerator(enum).
С помощью строки `@unique` перед нашей функцией мы говорим питону проверить все ли поля нашего enum имеют уникальные значения и если нет - выбросить ошибку

С помощью строки @classmethod перед нашей функцией мы получаем возможность доступа к самому классу (его полям, функциям),
который мы тут описываем, через cls, которая идет первым параметром в нашей функции.
 Так мы можем получить список названий полей и их значений с помощью специального поля members

Эта функция возвращает массив с парами (значение, имя поля) с помощью специального поля класса Enum - __members__,
который хранит в себе отсортированный словарь в котором связаны имена вариантов значений перечисляемого типа (например: initial) и их значения (0, для initial)

``` python
class User(Model):
    tg = IntegerField(default=0, help_text='Telegram User Id')
    vk = IntegerField(default=0, help_text='VK User Id')
    state = IntegerField(default=EUserState.initial.value, choices=EUserState.as_choices(),
                         help_text='Current bot state for user')
    state_param = TextField(default='', help_text='Param for state')

    def set_state(self, state: EUserState, param=''):
        self.state = state.value
        self.state_param = param

    def __repr__(self):
        return '<User tg={} vk={} state={}:{}>'.format(self.tg, self.vk, EUserState(self.state).name,
                                                       self.state_param)

    class Meta:
        database = database # указываем к какой базе данных относится таблица
        table_name = 'app_users'
        primary_key = CompositeKey('tg', 'vk') # однозначно идентифицировать пользователя можно будет по связке его id в телеграме и id в вконтакте, т.е. не может существовать # двух пользователей, у которых и одинаковые id в телеграме и одинаковые id в вконтакте  
```

Здесь происходит создание класса User, он наследуется от класса Model из модуля ORM peewee
ORM — прослойка между базой данных и кодом который пишет программист, которая позволяет созданные в программе объекты складывать/получать в/из бд.
Модель - это класс, описывающий какую-либо сущность, а не чистое поведение и логику

Так наша таблица выглядит в базе данных
![User table](https://i.imgur.com/ZaaS0tu.png)

Это описание сущности в базе данных
Таким образом модель - описание сущности на языке программирования, а схема таблицы - описание сущности в базе данных.
Так каждая строка в таблице базы будет эквивалентна экземпляру класса модели

Мы создаем класс User, в котором указываем поля и их типы данных (для этого используются классы из модуля ORM,
чтобы она могла сопоставить тип поля в базе с типом поля класса,
в эти классы мы передаем параметр default - значение, которое будет по умолчанию при создании новой записи в таблице,
если не передано другое, а также help_text - комментарий к полю для будущих разработчиков)
Так же в случае state, мы передаем choices - строгое перечисление вариантов значений, которые возможны в этом поле,
теперь мы не сможем занести в базу другие по ошибке

В функциях set_state и __repr__ первым аргументом стоит self, что же это?
self - это ссылка на экземпляр класса, у которого была вызвана эта функция.

То есть если мы создадим класс Cow, а внутри определим функцию printName и поле под имя - name,
то сможем создать два экземпляра класса Cow, при создании передав разные имена для коров. Пусть будут Мурка и Буренка

``` python
# This Python file uses the following encoding: utf-8
class Cow():
    name = ''
    def __init__(self, newCowName):
        self.name = newCowName

    def printName(self):
        print(self.name)

murka = Cow('Мурка')
burenka = Cow('Буренка')

murka.printName() # будет выведено "Мурка"
burenka.printName() # будет выведено "Буренка"
```

__repr__ - это функция, вызывая которую мы получаем однозначное представление объекта в виде строки,
которое можно использовать, чтобы воссоздать точно такой же объект, а если это невозможно,
то вывести какое-нибудь полезное сообщение.

``` python
def create_tables():
    with database: # Конструкция with ... as применяется для гарантии того, что критические функции выполнятся в любом случае. Самый распространённый пример использования этой конструкции - открытие файлов. 
        database.create_tables([User])
    # закрываем подключение, чтобы не могли слушать ничего страшного.
    database.close()
```

И наконец функция create_tables
Внутри нее инструкция with удостоверяется, что database существует (мы могли не подключиться к базе данных из-за ошибки,
например из-за неверного логина или пароля для подключения)
И, если все хорошо, вызывает функцию create_tables (она описана в классе PostgresqlDatabase) и передает туда массив таблиц,
которые мы хотим создать (у нас в нем только 1 таблица - User)
Затем мы закрываем подключение к базе данных database.close()
